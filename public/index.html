<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Collaborative Pixel Drawing</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #controls {
      margin: 10px;
    }
    canvas {
      border: none;
      touch-action: none;
    }
    #chat {
      width: 300px;
      height: 150px;
      overflow-y: auto;
      border: 1px solid #ccc;
      margin-top: 10px;
      padding: 5px;
      background: #f9f9f9;
    }
    #userList {
      margin-top: 10px;
    }
    .cursor {
      position: absolute;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1>Collaborative Pixel Drawing</h1>
  <div id="controls">
    <input type="color" id="colorPicker" value="#000000" />
    <input type="range" id="brushSize" min="1" max="10" value="1" />
    <button id="eraserBtn">Eraser: Off</button>
    <button id="fillBtn">Fill</button>
    <input type="text" id="nameInput" placeholder="Enter your name" />
    <button id="renameBtn">Rename</button>
  </div>
  <canvas id="canvas" width="800" height="600"></canvas>
  <div id="chat"></div>
  <input type="text" id="chatInput" placeholder="Type a message..." />
  <button id="sendBtn">Send</button>
  <div id="userList"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const eraserBtn = document.getElementById('eraserBtn');
    const fillBtn = document.getElementById('fillBtn');
    const nameInput = document.getElementById('nameInput');
    const renameBtn = document.getElementById('renameBtn');
    const chat = document.getElementById('chat');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const userList = document.getElementById('userList');

    let drawing = false;
    let erasing = false;
    let fillMode = false;
    let username = 'Guest' + Math.floor(Math.random() * 1000);
    let userColor = colorPicker.value;
    const cursors = {};

    // Set white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    function draw(x, y, color, size) {
      ctx.fillStyle = color;
      ctx.fillRect(x - size / 2, y - size / 2, size, size);
    }

    function floodFill(x, y, fillColor) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;
      const stack = [[x, y]];
      const pixelPos = (x, y) => (y * width + x) * 4;

      const targetColor = [
        data[pixelPos(x, y)],
        data[pixelPos(x, y) + 1],
        data[pixelPos(x, y) + 2],
        data[pixelPos(x, y) + 3]
      ];

      const fillR = parseInt(fillColor.slice(1, 3), 16);
      const fillG = parseInt(fillColor.slice(3, 5), 16);
      const fillB = parseInt(fillColor.slice(5, 7), 16);

      if (
        targetColor[0] === fillR &&
        targetColor[1] === fillG &&
        targetColor[2] === fillB
      ) {
        return;
      }

      while (stack.length) {
        const [currX, currY] = stack.pop();
        const idx = pixelPos(currX, currY);
        if (
          currX >= 0 &&
          currY >= 0 &&
          currX < width &&
          currY < height &&
          data[idx] === targetColor[0] &&
          data[idx + 1] === targetColor[1] &&
          data[idx + 2] === targetColor[2]
        ) {
          data[idx] = fillR;
          data[idx + 1] = fillG;
          data[idx + 2] = fillB;
          data[idx + 3] = 255;
          stack.push(
            [currX + 1, currY],
            [currX - 1, currY],
            [currX, currY + 1],
            [currX, currY - 1]
          );
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function handleDraw(e) {
      const pos = getMousePos(e);
      if (fillMode) {
        floodFill(Math.floor(pos.x), Math.floor(pos.y), erasing ? '#ffffff' : colorPicker.value);
        socket.emit('fill', {
          x: Math.floor(pos.x),
          y: Math.floor(pos.y),
          color: erasing ? '#ffffff' : colorPicker.value
        });
        fillMode = false;
        return;
      }
      draw(pos.x, pos.y, erasing ? '#ffffff' : colorPicker.value, parseInt(brushSize.value));
      socket.emit('draw', {
        x: pos.x,
        y: pos.y,
        color: erasing ? '#ffffff' : colorPicker.value,
        size: parseInt(brushSize.value)
      });
    }

    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      handleDraw(e);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (drawing) {
        handleDraw(e);
      }
      const pos = getMousePos(e);
      socket.emit('cursor', { x: pos.x, y: pos.y });
    });

    canvas.addEventListener('mouseup', () => {
      drawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      drawing = false;
    });

    canvas.addEventListener('touchstart', (e) => {
      drawing = true;
      handleDraw(e);
    });

    canvas.addEventListener('touchmove', (e) => {
      if (drawing) {
        handleDraw(e);
      }
      const pos = getMousePos(e);
      socket.emit('cursor', { x: pos.x, y: pos.y });
      e.preventDefault();
    });

    canvas.addEventListener('touchend', () => {
      drawing = false;
    });

    eraserBtn.addEventListener('click', () => {
      erasing = !erasing;
      eraserBtn.textContent = erasing ? 'Eraser: On' : 'Eraser: Off';
    });

    fillBtn.addEventListener('click', () => {
      fillMode = true;
    });

    renameBtn.addEventListener('click', () => {
      const newName = nameInput.value.trim();
      if (newName) {
        username = newName;
        socket.emit('rename', username);
      }
    });

    sendBtn.addEventListener('click', () => {
      const message = chatInput.value.trim();
      if (message) {
        socket.emit('chat', message);
        chatInput.value = '';
      }
    });

    socket.on('draw', (data) => {
      draw(data.x, data.y, data.color, data.size);
    });

    socket.on('fill', (data) => {
      floodFill(data.x, data.y, data.color);
    });

    socket.on('chat', (msg) => {
      const p = document.createElement('p');
      p.textContent = msg;
      chat.appendChild(p);
      chat.scrollTop = chat.scrollHeight;
    });

    socket.on('userList', (list) => {
      userList.textContent = 'Online: ' + list.join(', ');
    });

    socket.on('cursor', (data) => {
      if (!cursors[data.id]) {
        const cursor = document.createElement('div');
        cursor.classList.add('cursor');
        cursor.style.width = '10px';
        cursor.style.height = '10px';
        cursor.style.backgroundColor = data.color;
        cursor.style.borderRadius = '50%';
        cursor.style.position = 'absolute';
        document.body.appendChild(cursor);
        cursors[data.id] = cursor;
      }
      const cursor = cursors[data.id];
      cursor.style.left = canvas.offsetLeft + data.x + 'px';
      cursor.style.top = canvas.offsetTop + data.y + 'px';
    });

    socket.on('removeCursor', (id) => {
      if (cursors[id]) {
        document.body.removeChild(cursors[id]);
        delete cursors[id];
      }
    });

    // Initial setup
    socket.emit('rename', username);
  </script>
</body>
</html>
